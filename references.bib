
@misc{noauthor_algebra_nodate,
	title = {Algebra: {Expressions} {And} {Equations} - {Definition} and {Examples}},
	shorttitle = {Algebra},
	url = {https://byjus.com/maths/algebra-expressions-equations/},
	abstract = {Learn about algebra expressions and equations and learn how to solve algebraic expressions and equations. Visit BYJU'S to learn complete information.},
	language = {en},
	urldate = {2022-12-13},
	journal = {BYJUS},
}

@misc{noauthor_expression_2015,
	title = {Expression {Tree}},
	url = {https://www.geeksforgeeks.org/expression-tree/},
	abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},
	language = {en-us},
	urldate = {2022-12-13},
	journal = {GeeksforGeeks},
	month = aug,
	year = {2015},
}

@article{hartmanis_computational_1965,
	title = {On the {Computational} {Complexity} of {Algorithms}},
	volume = {117},
	issn = {0002-9947},
	url = {https://www.jstor.org/stable/1994208},
	doi = {10.2307/1994208},
	urldate = {2022-12-06},
	journal = {Transactions of the American Mathematical Society},
	author = {Hartmanis, J. and Stearns, R. E.},
	year = {1965},
	pages = {285--306},
}

@misc{noauthor_recursively_2022,
	title = {Recursively enumerable language},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Recursively_enumerable_language&oldid=1102289416},
	abstract = {In mathematics, logic and computer science, a formal language is called recursively enumerable (also recognizable, partially decidable, semidecidable, Turing-acceptable or Turing-recognizable) if it is a recursively enumerable subset in the set of all possible words over the alphabet of the language, i.e., if there exists a Turing machine which will enumerate all valid strings of the language.
Recursively enumerable languages are known as type-0 languages in the Chomsky hierarchy of formal languages. All regular, context-free, context-sensitive and recursive languages are recursively enumerable.
The class of all recursively enumerable languages is called RE.},
	language = {en},
	urldate = {2022-12-06},
	journal = {Wikipedia},
	month = aug,
	year = {2022},
	note = {Page Version ID: 1102289416},
}

@misc{noauthor_yourkit_nodate,
	title = {{YourKit} {Java} {Profiler} help - {Time} measurement ({CPU} time, wall time)},
	url = {https://www.yourkit.com/docs/java/help/times.jsp},
	urldate = {2022-11-30},
}

@misc{noauthor_cpu_nodate,
	title = {{CPU} time used by {MATLAB} - {MATLAB} cputime},
	url = {https://www.mathworks.com/help/matlab/ref/cputime.html},
	urldate = {2022-11-30},
}

@article{ahmed_novel_2020,
	title = {A novel time efficient structure-preserving splitting method for the solution of two-dimensional reaction-diffusion systems},
	volume = {2020},
	issn = {1687-1847},
	url = {https://doi.org/10.1186/s13662-020-02659-0},
	doi = {10.1186/s13662-020-02659-0},
	abstract = {In this article, the first part is concerned with the important questions related to the existence and uniqueness of solutions for nonlinear reaction-diffusion systems. Secondly, an efficient positivity-preserving operator splitting nonstandard finite difference scheme (NSFD) is designed for such a class of systems. The presented formulation is unconditionally stable as well as implicit in nature and even time efficient. The proposed NSFD operator splitting technique also preserves all the important properties possessed by continuous systems like positivity, convergence to the fixed points of the system, and boundedness. The proposed algorithm is implicit in nature but more efficient in time than the extensively used Euler method.},
	number = {1},
	urldate = {2022-11-29},
	journal = {Advances in Difference Equations},
	author = {Ahmed, Nauman and Korkmaz, Alper and Rafiq, M. and Baleanu, Dumitru and Alshomrani, Ali Saleh and Rehman, M. A. and Iqbal, M. S.},
	month = may,
	year = {2020},
	keywords = {Numerical simulations, Operator splitting finite difference scheme, Positivity, Reaction-diffusion models},
	pages = {197},
}

@article{cole_high-accuracy_1997,
	title = {A high-accuracy realization of the {Yee} algorithm using non-standard finite differences},
	volume = {45},
	issn = {1557-9670},
	doi = {10.1109/22.588615},
	abstract = {New nonstandard second-order finite differences (FD's) are introduced, which when substituted into the Yee algorithm, reduce the solution error by a factor of 10/sup -4/ on a coarse computational grid. Using /spl lambda//h (grid spacings per wavelength)=8, one achieves the same accuracy as the standard Yee algorithm does at /spl lambda//h=1140. In addition, greater algorithmic stability allows a reduction in the number of iterations needed to solve a problem.},
	number = {6},
	journal = {IEEE Transactions on Microwave Theory and Techniques},
	author = {Cole, J.B.},
	month = jun,
	year = {1997},
	keywords = {Animation, Computational efficiency, Data visualization, Finite difference methods, Grid computing, Laplace equations, Maxwell equations, Stability, Time domain analysis},
	pages = {991--996},
}

@misc{noauthor_ordinary_2022,
	title = {Ordinary differential equation},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Ordinary_differential_equation&oldid=1117652005},
	abstract = {In mathematics, an ordinary differential equation (ODE) is a differential equation whose unknown(s) consists of one (or more) function(s) of one variable and involves the derivatives of those functions. The term ordinary is used in contrast with the term partial differential equation which may be with respect to more than one independent variable.},
	language = {en},
	urldate = {2022-11-29},
	journal = {Wikipedia},
	month = oct,
	year = {2022},
	note = {Page Version ID: 1117652005},
}

@misc{raboy_parse_nodate,
	title = {Parse {With} {The} {Shunting} {Yard} {Algorithm} {Using} {JavaScript}},
	url = {https://www.thepolyglotdeveloper.com/2015/03/parse-with-the-shunting-yard-algorithm-using-javascript/},
	abstract = {Parse an infix notation equation to reverse polish notation (RPN) using the Shunting Yard algorithm and JavaScript. Prepares for solving math expressions.},
	language = {en-us},
	urldate = {2022-09-06},
	journal = {The Polyglot Developer},
	author = {Raboy, Nic},
}

@misc{noauthor_heuns_2021,
	title = {Heun's method},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Heun%27s_method&oldid=1014135572},
	abstract = {In mathematics and computational science, Heun's method may refer to the improved or modified Euler's method (that is, the explicit trapezoidal rule), or a similar two-stage Runge–Kutta method. It is named after Karl Heun and is a numerical procedure for solving ordinary differential equations (ODEs) with a given initial value. Both variants can be seen as extensions of the Euler method into two-stage second-order Runge–Kutta methods.
The procedure for calculating the numerical solution to the initial value problem:

  
    
      
        
          y
          ′
        
        (
        t
        )
        =
        f
        (
        t
        ,
        y
        (
        t
        )
        )
        ,
        
        
        y
        (
        
          t
          
            0
          
        
        )
        =
        
          y
          
            0
          
        
        ,
      
    
    \{{\textbackslash}displaystyle y'(t)=f(t,y(t)),{\textbackslash}qquad {\textbackslash}qquad y(t\_\{0\})=y\_\{0\},\}
  by way of Heun's method, is to first calculate the intermediate value 
  
    
      
        
          
            
              
                y
                {\textasciitilde}
              
            
          
          
            i
            +
            1
          
        
      
    
    \{{\textbackslash}displaystyle \{{\textbackslash}tilde \{y\}\}\_\{i+1\}\}
   and then the final approximation  
  
    
      
        
          y
          
            i
            +
            1
          
        
      
    
    \{{\textbackslash}displaystyle y\_\{i+1\}\}
   at the next integration point.

  
    
      
        
          
            
              
                y
                {\textasciitilde}
              
            
          
          
            i
            +
            1
          
        
        =
        
          y
          
            i
          
        
        +
        h
        f
        (
        
          t
          
            i
          
        
        ,
        
          y
          
            i
          
        
        )
      
    
    \{{\textbackslash}displaystyle \{{\textbackslash}tilde \{y\}\}\_\{i+1\}=y\_\{i\}+hf(t\_\{i\},y\_\{i\})\}
  

  
    
      
        
          y
          
            i
            +
            1
          
        
        =
        
          y
          
            i
          
        
        +
        
          
            h
            2
          
        
        [
        f
        (
        
          t
          
            i
          
        
        ,
        
          y
          
            i
          
        
        )
        +
        f
        (
        
          t
          
            i
            +
            1
          
        
        ,
        
          
            
              
                y
                {\textasciitilde}
              
            
          
          
            i
            +
            1
          
        
        )
        ]
        ,
      
    
    \{{\textbackslash}displaystyle y\_\{i+1\}=y\_\{i\}+\{{\textbackslash}frac \{h\}\{2\}\}[f(t\_\{i\},y\_\{i\})+f(t\_\{i+1\},\{{\textbackslash}tilde \{y\}\}\_\{i+1\})],\}
  
where 
  
    
      
        h
      
    
    \{{\textbackslash}displaystyle h\}
   is the step size and 
  
    
      
        
          t
          
            i
            +
            1
          
        
        =
        
          t
          
            i
          
        
        +
        h
      
    
    \{{\textbackslash}displaystyle t\_\{i+1\}=t\_\{i\}+h\}
  .},
	language = {en},
	urldate = {2022-08-15},
	journal = {Wikipedia},
	month = mar,
	year = {2021},
	note = {Page Version ID: 1014135572},
}

@article{noauthor_notitle_nodate,
}

@misc{is2pidguy_how_2019,
	title = {How to write a math expression parser (in {JavaScript})},
	url = {https://medium.com/@stoopidguy1992/how-to-write-a-math-expression-parser-in-javascript-b5147bc9466b},
	abstract = {Here goes my first post.},
	language = {en},
	urldate = {2022-05-06},
	journal = {Medium},
	author = {{Is2PidGuy}},
	month = jan,
	year = {2019},
}

@article{borrelli_user_nodate,
	title = {User {Interface} {Design} for {E}-learning {Platform} and {Institutional}
portal of {University} of {Foggia}},
	volume = {3025},
	url = {http://ceur-ws.org/Vol-3025/paper8.pdf},
	journal = {University of Foggia},
	author = {Borrelli, Lucia and Perrella, Sara},
	pages = {8},
}

@article{deuflhard_short_2010,
	title = {A {Short} {History} of {Newton}’s {Method}},
	author = {Deuflhard, Peter},
	year = {2010},
}

@misc{noauthor_step-by-step_nodate,
	title = {Step-by-{Step} {Math}—{Wolfram}{\textbar}{Alpha} {Blog}},
	url = {https://blog.wolframalpha.com/2009/12/01/step-by-step-math/},
	urldate = {2022-04-27},
}

@misc{gupta_vs_2019,
	title = {{VS} {Code} {Extensions} {For} {Web} {Dev} {Productivity}},
	url = {https://betterprogramming.pub/vs-code-extension-for-web-dev-productivity-fa541654161f},
	abstract = {Make your experience in the editor colorful, streamlined, and powerful},
	language = {en},
	urldate = {2022-04-27},
	journal = {Medium},
	author = {Gupta, Deepak},
	month = dec,
	year = {2019},
}

@misc{web_dev_simplified_build_2019,
	title = {Build {A} {Calculator} {With} {JavaScript} {Tutorial}},
	url = {https://www.youtube.com/watch?v=j59qQ7YWLxw},
	abstract = {Projects are the best way to learn JavaScript, and a calculator is one of the best projects to choose. A calculator covers all the complex interactions with UI and JavaScript while still being simple enough for people of any skill level.

In this video I will walk you through the steps it takes to build a completely modern calculator using JavaScript best practices. If you want to learn JavaScript or improve your JavaScript skill this is a must do project.

📚 Materials:

Code: https://github.com/WebDevSimplified/V...

🧠 Concepts Covered:
 
- How to use ES6 classes to organize code
- How to sync JavaScript code with a UI
- CSS Grid
- Flexbox
- The best way to cleanly handle user input
- How to debug complicated edge cases

🌎 Find Me Here:

Twitter: https://twitter.com/DevSimplified
GitHub: https://github.com/WebDevSimplified
CodePen: https://codepen.io/WebDevSimplified


\#JavaScript \#WebDevelopment \#Programming},
	urldate = {2022-04-27},
	author = {{Web Dev Simplified}},
	month = apr,
	year = {2019},
}

@misc{basu_numerical_nodate,
	address = {Occidental College},
	type = {Class},
	title = {Numerical {Analysis} {MATH370}},
	author = {Basu, Treena},
}

@book{mathews_numerical_nodate,
	edition = {Fourth},
	title = {Numerical methods using {MATLAB}},
	isbn = {0-13-065248-2},
	author = {Mathews, John and Fink, Kurtis},
}

@misc{noauthor_newtons_2022,
	title = {Newton's method},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Newton%27s_method&oldid=1080657265},
	abstract = {In numerical analysis, Newton's method, also known as the Newton–Raphson method, named after Isaac Newton and Joseph Raphson, is a root-finding algorithm which produces successively better approximations to the roots (or zeroes) of a real-valued function. The most basic version starts with a single-variable function f defined for a real variable x, the function's derivative f′, and an initial guess x0 for a root of f. If the function satisfies sufficient assumptions and the initial guess is close, then

  
    
      
        
          x
          
            1
          
        
        =
        
          x
          
            0
          
        
        −
        
          
            
              f
              (
              
                x
                
                  0
                
              
              )
            
            
              
                f
                ′
              
              (
              
                x
                
                  0
                
              
              )
            
          
        
      
    
    \{{\textbackslash}displaystyle x\_\{1\}=x\_\{0\}-\{{\textbackslash}frac \{f(x\_\{0\})\}\{f'(x\_\{0\})\}\}\}
  is a better approximation of the root than x0. Geometrically, (x1, 0) is the intersection of the x-axis and the tangent of the graph of f at (x0, f(x0)): that is, the improved guess is the unique root of the linear approximation at the initial point. The process is repeated as

  
    
      
        
          x
          
            n
            +
            1
          
        
        =
        
          x
          
            n
          
        
        −
        
          
            
              f
              (
              
                x
                
                  n
                
              
              )
            
            
              
                f
                ′
              
              (
              
                x
                
                  n
                
              
              )
            
          
        
      
    
    \{{\textbackslash}displaystyle x\_\{n+1\}=x\_\{n\}-\{{\textbackslash}frac \{f(x\_\{n\})\}\{f'(x\_\{n\})\}\}\}
  until a sufficiently precise value is reached. This algorithm is first in the class of Householder's methods, succeeded by Halley's method. The method can also be extended to complex functions and to systems of equations.},
	language = {en},
	urldate = {2022-04-19},
	journal = {Wikipedia},
	month = apr,
	year = {2022},
	note = {Page Version ID: 1080657265},
}

@misc{noauthor_joseph_2022,
	title = {Joseph {Raphson}},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Joseph_Raphson&oldid=1077028147},
	abstract = {Joseph Raphson (c. 1668 – c. 1715) was an English mathematician and intellectual known best for the Newton–Raphson method.},
	language = {en},
	urldate = {2022-04-19},
	journal = {Wikipedia},
	month = mar,
	year = {2022},
	note = {Page Version ID: 1077028147},
}

@misc{noauthor_newton_nodate,
	title = {Newton {Raphson} {Method} {\textbar} {Brilliant} {Math} \& {Science} {Wiki}},
	url = {https://brilliant.org/wiki/newton-raphson-method/},
	abstract = {The Newton-Raphson method (also known as Newton\&\#39;s method) is a way to quickly find a good approximation for the root of a real-valued function ...},
	language = {en-us},
	urldate = {2022-04-19},
}

@article{pane_effectiveness_2014,
	title = {Effectiveness of {Cognitive} {Tutor} {Algebra} {I} at {Scale}},
	volume = {36},
	url = {https://www.jstor.org/stable/43773458},
	number = {2},
	journal = {American Educational Research Association},
	author = {Pane, John and Griffin, Ann and McCaffrey, Daniel and Karam, Rita},
	month = jun,
	year = {2014},
	pages = {19},
}

@misc{irwin_nces_nodate,
	title = {{NCES} {Blog} {\textbar} {Students}’ {Internet} {Access} {Before} and {During} the {Coronavirus} {Pandemic} by {Household} {Socioeconomic} {Status}},
	url = {https://nces.ed.gov/blogs/nces/post/students-internet-access-before-and-during-the-coronavirus-pandemic-by-household-socioeconomic-status},
	urldate = {2022-04-18},
	author = {Irwin, Véronique},
}

@misc{hemphill_nces_nodate,
	title = {{NCES} {Blog} {\textbar} {Students}’ {Access} to the {Internet} and {Digital} {Devices} at {Home}},
	url = {https://nces.ed.gov/blogs/nces/post/students-access-to-the-internet-and-digital-devices-at-home},
	urldate = {2022-04-18},
	author = {Hemphill, Cadelle and Wang, Yan and Scott, Chad and Wilburn, Grady},
}

@misc{scott_ethical_nodate,
	title = {Ethical {Web} {Development}},
	url = {https://www.ethicalweb.org/},
	urldate = {2022-04-18},
	author = {Scott, Adam},
}

@misc{coyle_final_nodate,
	title = {Final {Project}: {Speech} {Recognition}: {Affordances} and {Limitations} with {Accented} {Speech} {\textbar} {CCTP} 711 – {Semiotics} and {Cognitive} {Technology}},
	shorttitle = {Final {Project}},
	url = {https://blogs.commons.georgetown.edu/cctp-711-fall2018/2018/12/11/speech-recognition-affordances-and-limitations-with-accented-speech/},
	language = {en-US},
	urldate = {2022-04-18},
	author = {Coyle, Adrienne},
}

@misc{noauthor_shunting-yard_2022,
	title = {Shunting-yard algorithm},
	copyright = {Creative Commons Attribution-ShareAlike License},
	url = {https://en.wikipedia.org/w/index.php?title=Shunting-yard_algorithm&oldid=1074583221},
	abstract = {In computer science, the shunting-yard algorithm is a method for parsing arithmetical or logical expressions, or a combination of both, specified in infix notation. It can produce either a postfix notation string, also known as Reverse Polish notation (RPN), or an abstract syntax tree (AST). The algorithm was invented by Edsger Dijkstra and named the "shunting yard" algorithm because its operation resembles that of a railroad shunting yard. Dijkstra first described the Shunting Yard Algorithm in the Mathematisch Centrum report MR 34/61.
Like the evaluation of RPN, the shunting yard algorithm is stack-based. Infix expressions are the form of mathematical notation most people are used to, for instance "3 + 4" or "3 + 4 × (2 − 1)". For the conversion there are two text variables (strings), the input and the output. There is also a stack that holds operators not yet added to the output queue. To convert, the program reads each symbol in order and does something based on that symbol. The result for the above examples would be (in Reverse Polish notation) "3 4 +" and "3 4 2 1 − × +", respectively.
The shunting yard algorithm will correctly parse all valid infix expressions, but does not reject all invalid expressions. For example, "1 2 +" is not a valid infix expression, but would be parsed as "1 + 2". The algorithm can however reject expressions with mismatched parentheses.
The shunting-yard algorithm was later generalized into operator-precedence parsing.},
	language = {en},
	urldate = {2022-03-09},
	journal = {Wikipedia},
	month = mar,
	year = {2022},
	note = {Page Version ID: 1074583221},
}

@misc{noauthor_integral_nodate,
	title = {Integral {Calculator} • {With} {Steps}!},
	url = {https://www.integral-calculator.com/},
	urldate = {2022-03-09},
}

@article{kochmar_automated_2021,
	title = {Automated {Data}-{Driven} {Generation} of {Personalized} {Pedagogical} {Interventions} in {Intelligent} {Tutoring} {Systems}},
	issn = {1560-4306},
	url = {https://doi.org/10.1007/s40593-021-00267-x},
	doi = {10.1007/s40593-021-00267-x},
	abstract = {Intelligent tutoring systems (ITS) have been shown to be highly effective at promoting learning as compared to other computer-based instructional approaches. However, many ITS rely heavily on expert design and hand-crafted rules. This makes them difficult to build and transfer across domains and limits their potential efficacy. In this paper, we investigate how feedback in a large-scale ITS can be automatically generated in a data-driven way, and more specifically how personalization of feedback can lead to improvements in student performance outcomes. First, in this paper we propose a machine learning approach to generate personalized feedback in an automated way, which takes individual needs of students into account, while alleviating the need of expert intervention and design of hand-crafted rules. We leverage state-of-the-art machine learning and natural language processing techniques to provide students with personalized feedback using hints and Wikipedia-based explanations. Second, we demonstrate that personalized feedback leads to improved success rates at solving exercises in practice: our personalized feedback model is used in Korbit, a large-scale dialogue-based ITS with around 20,000 students launched in 2019. We present the results of experiments with students and show that the automated, data-driven, personalized feedback leads to a significant overall improvement of 22.95\% in student performance outcomes and substantial improvements in the subjective evaluation of the feedback.},
	language = {en},
	urldate = {2022-03-09},
	journal = {International Journal of Artificial Intelligence in Education},
	author = {Kochmar, Ekaterina and Vu, Dung Do and Belfer, Robert and Gupta, Varun and Serban, Iulian Vlad and Pineau, Joelle},
	month = jul,
	year = {2021},
}

@misc{ahearn_what_2016,
	title = {What is the {Orton}-{Gillingham} {Approach}? {\textbar} {Academy} of {Orton}-{Gillingham} {Practitioners} and {Educators}},
	shorttitle = {What is the {Orton}-{Gillingham} {Approach}?},
	url = {https://www.ortonacademy.org/resources/what-is-the-orton-gillingham-approach/},
	abstract = {Orton-Gillingham is an instructional approach intended primarily for use with individuals who have difficulty with reading, spelling, and writing of the sort associated with dyslexia.},
	language = {en-US},
	urldate = {2022-03-05},
	author = {Ahearn, Molly},
	month = dec,
	year = {2016},
}

@misc{noauthor_evidence-based_nodate,
	title = {Evidence-based math instruction: {What} you need to know},
	shorttitle = {Evidence-based math instruction},
	url = {https://www.understood.org/articles/en/evidence-based-math-instruction-for-struggling-students},
	abstract = {Learn the most effective ways to teach math to students who struggle. Understand the four types of evidence-based math instruction.},
	language = {en},
	urldate = {2022-03-05},
}

@misc{noauthor_is_nodate,
	title = {Is there such a thing as {Orton}–{Gillingham} for math?},
	url = {https://www.understood.org/articles/en/is-there-such-a-thing-as-orton-gillingham-for-math},
	abstract = {What is Orton–Gillingham for math? Is it a real thing? Learn about multisensory math instruction and how it can help kids who struggle with math.},
	language = {en},
	urldate = {2022-03-05},
}

@misc{noauthor_why_nodate,
	title = {Why do some kids find math hard?},
	url = {https://www.readandspell.com/us/struggling-with-math},
	abstract = {Learn more about students who are struggling with math because of dyscalculia, dyslexia, ADD/ADHD, dyspraxia, and/or visual processing difficulties.},
	language = {en-US},
	urldate = {2022-03-05},
	journal = {Touch-type Read and Spell (TTRS)},
}

@misc{fensterwald_10_nodate,
	title = {10 {California} districts struggle, and find some success, as they shift to {Common} {Core} math},
	url = {https://edsource.org/2019/10-california-districts-struggle-and-find-some-success-as-they-shift-to-common-core-math/615109},
	abstract = {Studies of the Math in Common project offer lessons for other districts and a warning: Steady progress takes a long-term commitment.},
	language = {en},
	urldate = {2022-03-05},
	journal = {EdSource},
	author = {Fensterwald, John},
}

@misc{noauthor_california_nodate,
	title = {California {Assessment} of {Student} {Performance} and {Progress} ({CAASPP})},
	url = {https://www.sjcoe.org/commoncore/CAASPP.aspx},
	urldate = {2022-03-05},
}

@misc{noauthor_packages_nodate,
	title = {packages - {Making} a website with {Mathematica}},
	url = {https://mathematica.stackexchange.com/questions/152663/making-a-website-with-mathematica},
	abstract = {This is the blog post that tells how wolfram came to be using Mathematica as their computation device},
	urldate = {2022-02-23},
	journal = {Mathematica Stack Exchange},
}

@misc{noauthor_202021_nodate,
	title = {2020–21 {Smarter} {Balanced} {ELA} and {Mathematics} {Detailed} {Test} {Results} – {CAASPP} {Reporting} ({CA} {Dept} of {Education})},
	url = {https://caaspp-elpac.cde.ca.gov/caaspp/ViewReportSB?ps=true&lstTestYear=2021&lstTestType=B&lstGroup=1&lstGrade=13&lstSchoolType=A&lstCounty=00&lstDistrict=00000&lstSchool=0000000&lstSubject=m},
	abstract = {20-21 Math State testing results},
	urldate = {2022-02-23},
}

@misc{noauthor_secret_nodate,
	title = {The {Secret} behind the {Computational} {Engine} in {Wolfram}{\textbar}{Alpha}—{Wolfram}{\textbar}{Alpha} {Blog}},
	url = {https://blog.wolframalpha.com/2009/05/01/the-secret-behind-the-computational-engine-in-wolframalpha/},
	abstract = {This is the blog post that shows how wolfram came to be, they used mathematica},
	urldate = {2022-02-23},
}
